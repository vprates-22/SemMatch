"""
Module: semmatch.statistics_new.analyzers.geometry
--------------------------------------------------

This module contains analyzers for geometric matching results, specifically focusing on inlier
and projection-based match analysis.
"""
import numpy as np

from numpy.typing import NDArray
from collections.abc import Iterable

from semmatch.configs.base import Config
from semmatch.statistics.analyzers.base import DataAnalyzer
from semmatch.statistics.data_generators import InlierGenerator, ProjectionGenerator, PoseEstimationGenerator
from semmatch.statistics.pipeline_data import AnalysisResult, MatchResult, ErrorResult, PoseErrorResult


def generate_match_result(inliers: NDArray, threshold: float, key: str = 'default') -> MatchResult:
    """
    Generates a `MatchResult` object from a boolean array of inliers.

    Parameters
    ----------
    inliers : NDArray
        A boolean NumPy array where True indicates an inlier and False an outlier.
    threshold : float
        The threshold used to determine inliers.
    key : str, optional
        A unique identifier for this result, by default 'default'.

    Returns
    -------
    MatchResult
        An object containing the calculated true positives, false positives,
    """
    hits = inliers.sum()
    misses = (~inliers).sum()

    return MatchResult(
        key=key,
        threshold=threshold,

        true_positives=hits,
        false_positives=misses,
        false_negatives=0,
        true_negatives=0,
    )


class InliersMatchAnalyzer(DataAnalyzer):
    """
    Analyzes inlier matching results generated by `InlierGenerator`.

    This analyzer calculates true positives and false positives based on the
    inlier masks and a given threshold. It can handle both single and
    iterable `GeneratedData` objects from the `InlierGenerator`.
    """
    _data_generator_depedencies = [InlierGenerator]
    _data_result_type = MatchResult

    def analyze(self, generated_data) -> list[AnalysisResult]:
        """
        Analyzes the generated inlier data.

        If `inlier_data` is an iterable, it processes each item individually.
        Otherwise, it processes the single `inlier_data` object.

        Parameters
        ----------
        generated_data : dict[type[DataGenerator],
            list[GeneratedData]]
            A dictionary containing generated data, expected to have `InlierGenerator`
            as a key.

        Returns
        -------
        list[AnalysisResult] or AnalysisResult
            A list of `MatchResult` objects, one for each set of inlier data
            (or a single element list if `inlier_data` was not iterable).
        """
        inlier_data = generated_data[InlierGenerator]

        if not isinstance(inlier_data, Iterable):
            inlier_data = [inlier_data]

        result = []

        for data in inlier_data:
            result.append(generate_match_result(
                data.inliers, data.threshold, key=f"inlier_threshold:{data.threshold}"))

        return result


class ProjectionMatchAnalyzer(DataAnalyzer):
    """
    Analyzes projection-based matching results generated by `ProjectionGenerator`.

    This analyzer calculates true positives and false positives based on the
    inlier masks obtained from projection and a given threshold. It can handle
    both single and iterable `GeneratedData` objects from the `ProjectionGenerator`.
    """
    _data_generator_depedencies = [ProjectionGenerator]
    _data_result_type = MatchResult

    def __init__(self, config=None):
        default_config = Config({
            'projection_threshold': [6.0],
        }).merge_config(config)

        super().__init__(default_config)

    def analyze(self, generated_data) -> list[AnalysisResult]:
        """
        Analyzes the generated projection data to determine inliers based on
        configured projection thresholds.

        Parameters
        ----------
        generated_data : dict[type[DataGenerator], list[GeneratedData]]
            A dictionary containing generated data, expected to have `ProjectionGenerator`
            as a key, with a list containing a single `ProjectionData` object.

        Returns
        -------
        list[AnalysisResult]
            A list of `MatchResult` objects, one for each `projection_threshold`
            defined in the analyzer's configuration.
        """
        projection_data = generated_data[ProjectionGenerator][0]

        mkpts1 = projection_data.mkpts1
        projected_points = projection_data.projections
        valid = projection_data.valid

        result = []
        for threshold in self._config.projection_threshold:
            diffs = projected_points[valid] - mkpts1[valid]
            dists = np.linalg.norm(diffs, axis=1)

            inliers = np.zeros_like(valid)
            inliers[valid] = dists <= threshold

            result.append(generate_match_result(
                inliers, threshold, key=f"projection_threshold:{threshold}"))

        return result


class ReprojectionErrorAnalyzer(DataAnalyzer):
    """
    Analyzes projection error results generated by `ProjectionGenerator`.

    This analyzer computes reprojection errors of valid projected points
    and returns them as an `ErrorResult`.
    """
    _data_generator_depedencies = [ProjectionGenerator]
    _data_result_type = ErrorResult

    def analyze(self, generated_data) -> list[AnalysisResult]:
        """
        Computes the reprojection errors for valid projected points.

        Parameters
        ----------
        generated_data: dict[type[DataGenerator], list[GeneratedData]]
            A dictionary containing generated data, expected to have `ProjectionGenerator`
            as a key, with a list containing a single `ProjectionData` object.

        Returns
        -------
        list[AnalysisResult]
            A list containing a single `ErrorResult` with reprojection errors.
        """
        projection_data = generated_data[ProjectionGenerator][0]

        mkpts1 = projection_data.mkpts1
        projected_points = projection_data.projections
        valid = projection_data.valid

        reproj_errors = np.linalg.norm(
            projected_points[valid] - mkpts1[valid],
            axis=1
        )

        return [ErrorResult(errors=reproj_errors.tolist())]


class PoseEstimationAnalyzer(DataAnalyzer):
    """
    Analyzes pose estimation results generated by `PoseEstimationGenerator`.

    This analyzer computes rotation and translation errors between estimated
    and ground truth poses, returning them as an `ErrorResult`.
    """
    _data_generator_depedencies = [PoseEstimationGenerator]
    _data_result_type = ErrorResult

    def analyze(self, generated_data) -> list[AnalysisResult]:
        """
        Analyzes the generated pose data to compute rotation and translation errors.

        Parameters
        ----------
        generated_data : dict[type[DataGenerator], list[GeneratedData]]
            A dictionary containing generated data, expected to have `PoseEstimationGenerator`
            as a key, with a list of `PoseData` objects.

        Returns
        -------
        list[AnalysisResult]
            A list of `PoseErrorResult` objects, one for each `PoseData` object
            in the input.
        """
        pose_data = generated_data[PoseEstimationGenerator]
        if not isinstance(pose_data, Iterable):
            pose_data = [pose_data]

        results = []
        for pose in pose_data:
            R_est = pose.R_est
            t_est = pose.t_est
            R_gt = pose.R_gt
            t_gt = pose.t_gt

            threshold = pose.threshold

            rotation_error = None
            translation_error = None

            if not (R_gt is None or t_gt is None
                    or R_est is None or t_est is None):
                # --- Rotation error ---
                R_diff = R_est.T @ R_gt
                cos_angle = (np.trace(R_diff) - 1) / 2
                cos_angle = np.clip(cos_angle, -1.0, 1.0)
                rotation_error = np.degrees(np.arccos(cos_angle))

                # --- Translation error ---
                # Normalize vectors
                t_est_norm = t_est / np.linalg.norm(t_est)
                t_gt_norm = t_gt / np.linalg.norm(t_gt)

                # Compute cosine similarity
                dot_product = np.dot(t_est_norm, t_gt_norm)
                # numerical stability
                dot_product = np.clip(dot_product, -1.0, 1.0)

                # Convert to degrees
                angle_t = np.degrees(np.arccos(dot_product))
                translation_error = min(angle_t, 180.0 - angle_t)

            results.append(PoseErrorResult(
                key=f"ransac_thresholds:{threshold}",
                threshold=threshold,

                rotation_error=rotation_error,
                translation_error=translation_error,
            ))

        return results
